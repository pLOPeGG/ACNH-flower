import itertools as it
import json

from operator import mul
from collections import deque
from functools import reduce
from pprint import pprint
from typing import *

# This code uses informations provided by this source: https://docs.google.com/document/d/1ARIQCUc5YVEd01D7jtJT9EEJF45m07NXhAm4fOpNvCs/mobilebasic
# All flowers rules are explained deeply an thoroughly inside.


# Mixing rules for any genesself.
# (gene_flower_1, gene_flower_2): [(gene_hybrid_flower, probability of apparition)]
mix_d = {
    (0, 0): [(0, 1.0)],
    (1, 0): [(0, 0.5), (1, 0.5)],
    (0, 1): [(0, 0.5), (1, 0.5)],
    (1, 1): [(0, 0.25), (1, 0.5), (2, 0.25)],
    (2, 0): [(1, 1.0)],
    (0, 2): [(1, 1.0)],
    (2, 1): [(1, 0.5), (2, 0.5)],
    (1, 2): [(1, 0.5), (2, 0.5)],
    (2, 2): [(2, 1.0)],
}


def load_colors(file):
    """
    Reads a csv file containing color information about flowers.
    """
    d = {}

    def helper(s):
        return sum(1 for c in s if c.isupper())

    with open(file, "r") as fp:
        for line in fp.readlines():
            gene, *_, color = line.strip().split("\t")

            gene = (
                helper(gene[0:2]),
                helper(gene[2:4]),
                helper(gene[4:6]),
                helper(gene[6:8]),
            )
            d[gene] = color
    return d


flower_color = load_colors("roses.csv")


class Flower:
    def __init__(self, genes: Sequence[int]):
        """
        Create a Flower based on its genes.
        Genes are represented by a sequence of 4 integers 0⩽x_i⩽2
        """
        self.genes = tuple(genes)
        self.color = flower_color[self]

    def __add__(self, other) -> List[Tuple["Flower", float]]:
        """
        Compute all possible hybrids (and their probability) generated by self and another Flower.
        """
        res_genes = [mix_d[g] for g in zip(self.genes, other.genes)]

        res = []
        for p in it.product(*res_genes):
            genes, probs = zip(*p)
            prob = reduce(mul, probs)
            res.append((Flower(genes), prob))

        return res

    def __eq__(self, other) -> bool:
        if isinstance(other, Flower):
            return self.genes == other.genes
        else:
            return self.genes == other

    def __hash__(self):
        return hash(self.genes)

    def __str__(self) -> str:
        return f"{self.code()} {self.color}"

    def __repr__(self):
        return f"{self.code()} {self.color}"
        return f"Flower({self.genes})"

    def code(self) -> str:
        gene_name = [
            "rr Rr RR".split(),
            "yy Yy YY".split(),
            "WW Ww ww".split(),  # «W» gene is recessive to «w»
            "ss Ss SS".split(),  # Only for roses
        ]
        res = []
        for i, g in enumerate(self.genes):
            res.append(gene_name[i][g])

        return " ".join(res)


FlowerPedia = NewType('FlowerPedia', Dict[Flower, Tuple[Optional[Tuple[Flower, Flower]], Set[Flower], float]])


# Roses seeds genes.
base_red = Flower([2, 0, 2, 1])
base_yellow = Flower([0, 2, 2, 0])
base_white = Flower([0, 0, 1, 0])

# Only blue rose gene combination.
tgt_blue = Flower([2, 2, 0, 0])


def explore(base_flowers: List[Flower]) -> FlowerPedia:
    """
    Compute best path to obtain each flower using only `base_flowers`
    """
    dp = FlowerPedia({f: (None, set(), 1.0) for f in base_flowers})

    flower_l = base_flowers.copy()

    # Floyd Warshall algorithm with no negative cycles
    # Stop when to modification are made to the FlowerPedia
    
    modified = True
    while modified:
        modified = False
        for f1 in flower_l:
            _, pred_f1, prob_f1 = dp[f1]
            for f2 in flower_l:
                _, pred_f2, prob_f2 = dp[f2]
                
                # Compute unique flowers needed to produce f1 and f2
                pred_common = pred_f1 & pred_f2
                prob_common = (
                    prob_f1
                    * prob_f2
                    / reduce(mul, (dp[fi][2] for fi in pred_common), 1.0)  # All flower in pred_common are counter twice in `prob_f1 * prob_f2`
                                                                           # We must divide by `product(prob(i) for i in pred_common)`
                )

                ff = f1 + f2

                for f, p in ff:
                    prob_f = prob_common * p
                    if not f in dp:
                        dp[f] = ((f1, f2), pred_f1 | pred_f2 | {f1, f2}, prob_f)
                        modified = True

                    # We wanr to maximize overall probability of obtaining flower f.
                    elif dp[f][2] < prob_f:
                        dp[f] = ((f1, f2), pred_f1 | pred_f2 | {f1, f2}, prob_f)
                        modified = True

        flower_l = list(dp)  # All flowers obtained so far will be mixed during next iteration of algortihm.

    return dp


def ancestors(tgt: Flower, flowerpedia: FlowerPedia, mem: Dict[Flower, Dict]) -> Dict[str, Any]:
    """
    Determines best way to obtain Flower `tgt` given a `flowerpedia`
    Recursively get ancestors of `tgt`in the FlowerPedia and aggregate results.
    """
    # Memoization for speedup
    if tgt in mem:
        return mem[tgt]

    parents, *_ = flowerpedia[tgt]

    if parents is None:
        return {"color": flower_color[tgt]}
    else:
        p1, p2 = parents

        a1 = ancestors(p1, flowerpedia, mem)
        mem[p1] = a1

        a2 = ancestors(p2, flowerpedia, mem)
        mem[p2] = a2

        comb_prob = dict(p1 + p2)[tgt]
        return {
            "A": (str(p1), a1),
            "B": (str(p2), a2),
            "prob": f"{comb_prob:.03}",
            "color": flower_color[tgt],
        }



def main():
    flowerpedia = explore([base_red, base_white, base_yellow])
    # print(*flower_vocab.items(), sep="\n")

    pprint(flowerpedia[tgt_blue])
    pprint(ancestors(tgt_blue, flowerpedia, {}))


if __name__ == "__main__":
    main()
